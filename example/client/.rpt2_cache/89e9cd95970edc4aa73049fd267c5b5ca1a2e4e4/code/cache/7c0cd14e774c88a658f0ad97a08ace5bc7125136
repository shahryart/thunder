{"code":"import { isEqual } from \"lodash\";\r\n/**\r\n * LRUCache implements a basic LRU uing lodash's isEqual to deeply compare keys.\r\n */\r\nexport class LRUCache {\r\n    constructor(size) {\r\n        this.size = size;\r\n        this.cache = [];\r\n    }\r\n    add(key, value) {\r\n        for (let i = 0; i < this.cache.length; i++) {\r\n            if (isEqual(this.cache[i].key, key)) {\r\n                this.cache.splice(i, 1);\r\n                break;\r\n            }\r\n        }\r\n        this.cache.unshift({ key, value });\r\n        while (this.cache.length > this.size) {\r\n            this.cache.pop();\r\n        }\r\n    }\r\n    find(k) {\r\n        for (const { key, value } of this.cache) {\r\n            if (isEqual(key, k)) {\r\n                return value;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n}\r\n","dts":{"name":"/Users/shahryartariq/thunderenum/src/github.com/samsarahq/thunder/example/client/lru.d.ts","text":"/**\r\n * LRUCache implements a basic LRU uing lodash's isEqual to deeply compare keys.\r\n */\r\nexport declare class LRUCache<K, V> {\r\n    private readonly size;\r\n    private readonly cache;\r\n    constructor(size: number);\r\n    add(key: K, value: V): void;\r\n    find(k: K): V | undefined;\r\n}\r\n"}}
