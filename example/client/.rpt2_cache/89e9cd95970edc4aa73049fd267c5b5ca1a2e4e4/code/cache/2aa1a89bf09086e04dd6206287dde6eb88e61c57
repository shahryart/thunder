{"code":"import * as tslib_1 from \"tslib\";\r\n// PingingWebSocket is a WebSocket you can rely on. It has timeouts for all\r\n// operations, and performs its own pings to make sure the connection to the\r\n// backend remains functioning.\r\nexport class PingingWebSocket {\r\n    constructor(connectFunction, listener, options = {}) {\r\n        // Initialize our settings and state.\r\n        this.connectFunction = connectFunction;\r\n        this.listener = listener;\r\n        this.options = Object.assign({}, PingingWebSocket.defaultOptions, options);\r\n        this.hasShutdown = false;\r\n    }\r\n    // send sends a message string to the server. If the WebSocket isn't open,\r\n    // send fails silently.\r\n    send(message) {\r\n        if (this.socket && this.socket.readyState === WebSocket.OPEN) {\r\n            try {\r\n                this.socket.send(JSON.stringify(message));\r\n            }\r\n            catch (error) {\r\n                console.log(`pingingwebsocket: this.socket.send failed: ${error}`);\r\n            }\r\n        }\r\n    }\r\n    // close closes the PingingWebSocket, calling onClose on the listener if the\r\n    // WebSocket is still open. After close returns, no more functions on the\r\n    // listener will be called.\r\n    close() {\r\n        this.shutdown(PingingWebSocket.reasonCloseCalled);\r\n    }\r\n    // readyState returns the current underlying WebSocket's readyState.\r\n    get readyState() {\r\n        if (this.hasShutdown) {\r\n            return WebSocket.CLOSED;\r\n        }\r\n        else if (this.socket) {\r\n            return this.socket.readyState;\r\n        }\r\n        else {\r\n            // If we have no socket yet, we are still waiting for the connect\r\n            // promise to complete.\r\n            return WebSocket.CONNECTING;\r\n        }\r\n    }\r\n    connect() {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\r\n            console.log(\"pingingwebsocket: connecting\");\r\n            // Start the connection timeout.\r\n            this.connectTimeout = setTimeout(() => this.shutdown(PingingWebSocket.reasonConnectionTimeout), this.options.connectionTimeoutMs);\r\n            // Invoke the connectFunction.\r\n            let socket;\r\n            try {\r\n                socket = yield this.connectFunction();\r\n            }\r\n            catch (error) {\r\n                this.shutdown(`connectFunction: ${error}`);\r\n                return;\r\n            }\r\n            // Catch a shutdown that happened while connectFunction was running.\r\n            if (this.hasShutdown) {\r\n                socket.close();\r\n                return;\r\n            }\r\n            // Store the socket. If we need to close it later, shutdown will do so.\r\n            this.socket = socket;\r\n            // Register socket handlers. All handlers are no-ops once we have shutdown.\r\n            socket.onopen = () => {\r\n                if (this.hasShutdown) {\r\n                    return;\r\n                }\r\n                console.log(\"pingingwebsocket: opened\");\r\n                // Clear the timeout now that the connection has opened.\r\n                if (this.connectTimeout) {\r\n                    clearTimeout(this.connectTimeout);\r\n                    this.connectTimeout = undefined;\r\n                }\r\n                // Start pinging. We will send the first ping after pingIntervalMs.\r\n                this.sendPingTimeout = setTimeout(() => this.sendPing(), this.options.pingIntervalMs);\r\n                // Notify the listener.\r\n                this.listener.onOpen();\r\n            };\r\n            socket.onerror = (e) => {\r\n                if (this.hasShutdown) {\r\n                    return;\r\n                }\r\n                // Shutdown on error.\r\n                this.shutdown(`socket error: ${e}`);\r\n            };\r\n            socket.onclose = (e) => {\r\n                if (this.hasShutdown) {\r\n                    return;\r\n                }\r\n                // Shutdown on close.\r\n                this.shutdown(`socket close: ${e.reason}`);\r\n            };\r\n            socket.onmessage = (e) => {\r\n                if (this.hasShutdown) {\r\n                    return;\r\n                }\r\n                // Parse the message.\r\n                let envelope;\r\n                try {\r\n                    envelope = JSON.parse(e.data);\r\n                }\r\n                catch (error) {\r\n                    this.shutdown(`socket message JSON.parse: ${error}`);\r\n                    return;\r\n                }\r\n                // If it is a ping reply, clear the timeout and schedule a new ping.\r\n                if (envelope.type === \"echo\") {\r\n                    if (this.receivePingTimeout) {\r\n                        clearTimeout(this.receivePingTimeout);\r\n                        this.receivePingTimeout = undefined;\r\n                    }\r\n                    if (this.sendPingTimeout) {\r\n                        clearTimeout(this.sendPingTimeout);\r\n                        this.sendPingTimeout = undefined;\r\n                    }\r\n                    this.sendPingTimeout = setTimeout(() => this.sendPing(), this.options.pingIntervalMs);\r\n                }\r\n                // Notify the listener.\r\n                this.listener.onMessage(envelope);\r\n            };\r\n        });\r\n    }\r\n    // sendPing sends a ping and sets up a timeout for the response.\r\n    sendPing() {\r\n        if (this.sendPingTimeout) {\r\n            clearTimeout(this.sendPingTimeout);\r\n            this.sendPingTimeout = undefined;\r\n        }\r\n        this.send({ type: \"echo\" });\r\n        if (this.receivePingTimeout) {\r\n            clearTimeout(this.receivePingTimeout);\r\n            this.receivePingTimeout = undefined;\r\n        }\r\n        this.receivePingTimeout = setTimeout(() => this.shutdown(PingingWebSocket.reasonPingTimeout), this.options.pingTimeoutMs);\r\n    }\r\n    // shutdown shuts down the websocket, clears all timeouts and notifies the\r\n    // listener.\r\n    shutdown(reason) {\r\n        // Ensure shutdown is idempotent.\r\n        if (this.hasShutdown) {\r\n            return;\r\n        }\r\n        this.hasShutdown = true;\r\n        console.log(`pingingwebsocket: shutdown: ${reason}`);\r\n        // Shut down the webssocket.\r\n        if (this.socket) {\r\n            try {\r\n                this.socket.close();\r\n            }\r\n            catch (error) {\r\n                console.log(`pingingwebsocket: this.socket.close failed: ${error}`);\r\n            }\r\n            this.socket = undefined;\r\n        }\r\n        // Clear all timeouts.\r\n        if (this.connectTimeout) {\r\n            clearTimeout(this.connectTimeout);\r\n            this.connectTimeout = undefined;\r\n        }\r\n        if (this.sendPingTimeout) {\r\n            clearTimeout(this.sendPingTimeout);\r\n            this.sendPingTimeout = undefined;\r\n        }\r\n        if (this.receivePingTimeout) {\r\n            clearTimeout(this.receivePingTimeout);\r\n            this.receivePingTimeout = undefined;\r\n        }\r\n        // Notify the listener.\r\n        this.listener.onClose(reason);\r\n    }\r\n}\r\n// defaultOptions provides a reasonable set of default PingingWebSocket options.\r\nPingingWebSocket.defaultOptions = Object.freeze({\r\n    connectionTimeoutMs: 30000,\r\n    pingIntervalMs: 30000,\r\n    pingTimeoutMs: 30000,\r\n});\r\nPingingWebSocket.reasonPingTimeout = \"ping timeout\";\r\nPingingWebSocket.reasonConnectionTimeout = \"connection timeout\";\r\nPingingWebSocket.reasonCloseCalled = \"close called\";\r\nexport default PingingWebSocket;\r\n","dts":{"name":"/Users/shahryartariq/thunderenum/src/github.com/samsarahq/thunder/example/client/pingingwebsocket.d.ts","text":"interface Options {\r\n    connectionTimeoutMs: number;\r\n    pingIntervalMs: number;\r\n    pingTimeoutMs: number;\r\n}\r\nexport declare type OutEnvelope = {\r\n    type: \"subscribe\";\r\n    id: string;\r\n    message: {\r\n        query: string;\r\n        variables: any;\r\n    };\r\n    extensions?: Record<string, any>;\r\n} | {\r\n    type: \"mutate\";\r\n    id: string;\r\n    message: {\r\n        query: string;\r\n        variables: any;\r\n    };\r\n    extensions?: Record<string, any>;\r\n} | {\r\n    type: \"unsubscribe\";\r\n    id: string;\r\n} | {\r\n    type: \"echo\";\r\n};\r\nexport declare type InEnvelope = {\r\n    type: \"update\";\r\n    id: string;\r\n    message: any;\r\n    metadata?: Record<string, any>;\r\n} | {\r\n    type: \"result\";\r\n    id: string;\r\n    message: any;\r\n    metadata?: Record<string, any>;\r\n} | {\r\n    type: \"error\";\r\n    id: string;\r\n    message: string;\r\n    metadata?: Record<string, any>;\r\n} | {\r\n    type: \"echo\";\r\n};\r\nexport declare type ConnectFunction = () => Promise<WebSocket>;\r\nexport interface SocketListener {\r\n    onOpen(): void;\r\n    onMessage(message: any): void;\r\n    onClose(reason: string): void;\r\n}\r\nexport declare class PingingWebSocket {\r\n    static readonly defaultOptions: Options;\r\n    static readonly reasonPingTimeout: string;\r\n    static readonly reasonConnectionTimeout: string;\r\n    static readonly reasonCloseCalled: string;\r\n    private readonly connectFunction;\r\n    private readonly listener;\r\n    private readonly options;\r\n    private socket?;\r\n    private hasShutdown;\r\n    private connectTimeout?;\r\n    private sendPingTimeout?;\r\n    private receivePingTimeout?;\r\n    constructor(connectFunction: ConnectFunction, listener: SocketListener, options?: Partial<Options>);\r\n    send(message: OutEnvelope): void;\r\n    close(): void;\r\n    readonly readyState: number;\r\n    connect(): Promise<void>;\r\n    private sendPing;\r\n    private shutdown;\r\n}\r\nexport default PingingWebSocket;\r\n"}}
