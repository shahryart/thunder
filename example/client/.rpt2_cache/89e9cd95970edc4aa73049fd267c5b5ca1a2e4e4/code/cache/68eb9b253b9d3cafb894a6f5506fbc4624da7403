{"code":"import { LRUCache } from \"./lru\";\r\nimport { merge } from \"./merge\";\r\nimport { ReconnectingWebSocket } from \"./reconnectingwebsocket\";\r\nexport const ErrorNotConnected = \"not connected\";\r\nexport const ErrorMutationTimeout = \"mutation timed out\";\r\nexport const ErrorConnectionClosed = \"connection closed\";\r\nfunction dataFromSubscription(subscription) {\r\n    return Object.freeze({\r\n        state: subscription.state,\r\n        value: subscription.value,\r\n        error: subscription.error,\r\n    });\r\n}\r\nexport class GraphQLError extends Error {\r\n    constructor(message, requestId) {\r\n        super(message);\r\n        this.requestId = requestId;\r\n        // Set the prototype explicitly.\r\n        Object.setPrototypeOf(this, GraphQLError.prototype);\r\n    }\r\n}\r\nclass Connection {\r\n    constructor(connectFunction) {\r\n        this.nextId = 0;\r\n        this.subscriptions = new Map();\r\n        this.mutations = new Map();\r\n        this.past = new LRUCache(100);\r\n        this.initialRetryDelay = 1000;\r\n        this.maxRetryDelay = 60000;\r\n        this.mutationTimeoutMs = 10000;\r\n        this.socket = new ReconnectingWebSocket(connectFunction, {\r\n            onOpen: this.handleOpen.bind(this),\r\n            onClose: this.handleClose.bind(this),\r\n            onMessage: this.handleMessage.bind(this),\r\n        });\r\n        this.socket.reconnect();\r\n    }\r\n    makeId() {\r\n        return (this.nextId++).toString();\r\n    }\r\n    subscribe({ query, variables, observer, }) {\r\n        const id = this.makeId();\r\n        const cached = this.past.find({\r\n            query,\r\n            variables,\r\n        });\r\n        const subscription = {\r\n            state: cached ? \"cached\" : \"loading\",\r\n            retryDelay: this.initialRetryDelay,\r\n            retryHandle: undefined,\r\n            query,\r\n            variables,\r\n            observer,\r\n            value: cached,\r\n            error: undefined,\r\n        };\r\n        this.subscriptions.set(id, subscription);\r\n        if (this.socket.state === \"connected\") {\r\n            this.send({\r\n                id,\r\n                type: \"subscribe\",\r\n                message: { query, variables },\r\n            });\r\n        }\r\n        return {\r\n            close: () => {\r\n                const sub = this.subscriptions.get(id);\r\n                if (!sub) {\r\n                    return;\r\n                }\r\n                if (sub.value !== undefined) {\r\n                    this.past.add({ query, variables }, sub.value);\r\n                }\r\n                this.subscriptions.delete(id);\r\n                if (this.socket.state === \"connected\") {\r\n                    this.send({ id, type: \"unsubscribe\" });\r\n                }\r\n            },\r\n            data: () => {\r\n                return dataFromSubscription(subscription);\r\n            },\r\n        };\r\n    }\r\n    mutate({ query, variables, }) {\r\n        const id = this.makeId();\r\n        if (this.socket.state === \"connected\") {\r\n            this.send({ id, type: \"mutate\", message: { query, variables } });\r\n        }\r\n        else {\r\n            return Promise.reject(new Error(ErrorNotConnected));\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            const mutation = {\r\n                query,\r\n                variables,\r\n                timeout: setTimeout(() => mutation.reject(new Error(ErrorMutationTimeout)), this.mutationTimeoutMs),\r\n                resolve,\r\n                reject,\r\n            };\r\n            this.mutations.set(id, mutation);\r\n        });\r\n    }\r\n    notify(subscription) {\r\n        subscription.observer(dataFromSubscription(subscription));\r\n    }\r\n    retry(id) {\r\n        const subscription = this.subscriptions.get(id);\r\n        if (subscription === undefined) {\r\n            return;\r\n        }\r\n        this.send({\r\n            id,\r\n            type: \"subscribe\",\r\n            message: { query: subscription.query, variables: subscription.variables },\r\n        });\r\n    }\r\n    open() {\r\n        this.socket.reconnect();\r\n    }\r\n    close() {\r\n        this.socket.close();\r\n    }\r\n    send(message) {\r\n        this.socket.send(message);\r\n    }\r\n    handleOpen() {\r\n        for (const [id, subscription] of this.subscriptions) {\r\n            this.send({\r\n                id,\r\n                type: \"subscribe\",\r\n                message: {\r\n                    query: subscription.query,\r\n                    variables: subscription.variables,\r\n                },\r\n            });\r\n            if (subscription.retryHandle) {\r\n                clearTimeout(subscription.retryHandle);\r\n                subscription.retryHandle = undefined;\r\n            }\r\n        }\r\n    }\r\n    handleClose() {\r\n        for (const [, subscription] of this.subscriptions) {\r\n            if (subscription.state === \"subscribed\") {\r\n                subscription.state = \"cached\";\r\n                this.notify(subscription);\r\n            }\r\n        }\r\n        for (const [, mutation] of this.mutations) {\r\n            mutation.reject(new Error(ErrorConnectionClosed));\r\n        }\r\n        this.mutations.clear();\r\n    }\r\n    handleMessage(envelope) {\r\n        let subscription;\r\n        let mutation;\r\n        switch (envelope.type) {\r\n            case \"update\":\r\n                subscription = this.subscriptions.get(envelope.id);\r\n                if (subscription !== undefined) {\r\n                    if (subscription.state !== \"subscribed\") {\r\n                        subscription.state = \"subscribed\";\r\n                        subscription.error = undefined;\r\n                        subscription.retryDelay = this.initialRetryDelay;\r\n                    }\r\n                    subscription.value = merge(subscription.value, envelope.message);\r\n                    this.notify(subscription);\r\n                }\r\n                break;\r\n            case \"result\":\r\n                mutation = this.mutations.get(envelope.id);\r\n                if (mutation !== undefined) {\r\n                    mutation.resolve(merge(null, envelope.message));\r\n                    clearTimeout(mutation.timeout);\r\n                    this.mutations.delete(envelope.id);\r\n                }\r\n                break;\r\n            case \"error\":\r\n                const requestId = envelope.metadata && envelope.metadata.requestId;\r\n                const requestIdMessage = requestId ? `RequestID:\\n${requestId}\\n` : \"\";\r\n                subscription = this.subscriptions.get(envelope.id);\r\n                if (subscription !== undefined) {\r\n                    console.error(\"Subscription failed.\", requestIdMessage, \"Query:\\n\", subscription.query, \"\\nVariables:\\n\", subscription.variables, \"\\nError:\\n\", envelope.message);\r\n                    subscription.state = \"error\";\r\n                    subscription.error = new GraphQLError(envelope.message, requestId);\r\n                    subscription.retryHandle = setTimeout(() => this.retry(envelope.id), subscription.retryDelay);\r\n                    subscription.retryDelay = Math.min(this.maxRetryDelay, subscription.retryDelay * 2);\r\n                    this.notify(subscription);\r\n                }\r\n                mutation = this.mutations.get(envelope.id);\r\n                if (mutation !== undefined) {\r\n                    console.error(\"Mutation failed.\", requestId, \"Query:\\n\", mutation.query, \"\\nVariables:\\n\", mutation.variables, \"\\nError:\\n\", envelope.message);\r\n                    mutation.reject(new GraphQLError(envelope.message, requestId));\r\n                    clearTimeout(mutation.timeout);\r\n                    this.mutations.delete(envelope.id);\r\n                }\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n}\r\nexport { Connection };\r\n","dts":{"name":"/Users/shahryartariq/thunderenum/src/github.com/samsarahq/thunder/example/client/connection.d.ts","text":"import { LRUCache } from \"./lru\";\r\nimport { ConnectFunction, InEnvelope, OutEnvelope } from \"./pingingwebsocket\";\r\nimport { ReconnectingWebSocket } from \"./reconnectingwebsocket\";\r\nexport declare const ErrorNotConnected = \"not connected\";\r\nexport declare const ErrorMutationTimeout = \"mutation timed out\";\r\nexport declare const ErrorConnectionClosed = \"connection closed\";\r\nexport interface GraphQLData<Result> {\r\n    data: GraphQLResult<Result>;\r\n}\r\nexport declare type GraphQLResult<Result> = {\r\n    state: \"error\";\r\n    error: GraphQLError;\r\n    value: never;\r\n} | {\r\n    state: \"loading\";\r\n    value?: Result;\r\n    error: never;\r\n} | {\r\n    state: \"subscribed\";\r\n    value: Result;\r\n    error: never;\r\n} | {\r\n    state: \"cached\";\r\n    value: Result;\r\n    error: never;\r\n};\r\nexport declare class GraphQLError extends Error {\r\n    requestId?: string | undefined;\r\n    constructor(message: string, requestId?: string | undefined);\r\n}\r\nexport declare type SubscriptionState = \"cached\" | \"loading\" | \"subscribed\" | \"error\";\r\ninterface GraphqlQuery<InputVariables> {\r\n    query: string;\r\n    variables: InputVariables;\r\n}\r\nexport interface Subscription<Result, InputVariables> extends GraphqlQuery<InputVariables> {\r\n    state: SubscriptionState;\r\n    retryDelay: number;\r\n    retryHandle: any;\r\n    observer: (data: GraphQLResult<Result>) => void;\r\n    value: Result | undefined;\r\n    error?: GraphQLError;\r\n}\r\nexport interface Mutation<InputVariables> extends GraphqlQuery<InputVariables> {\r\n    resolve: any;\r\n    reject: any;\r\n    timeout: number;\r\n}\r\nexport declare type Observer<Result> = (data: Result) => void;\r\ndeclare class Connection {\r\n    nextId: number;\r\n    subscriptions: Map<string, Subscription<object, object>>;\r\n    mutations: Map<string, Mutation<object>>;\r\n    past: LRUCache<{}, {}>;\r\n    initialRetryDelay: number;\r\n    maxRetryDelay: number;\r\n    mutationTimeoutMs: number;\r\n    socket: ReconnectingWebSocket;\r\n    constructor(connectFunction: ConnectFunction);\r\n    makeId(): string;\r\n    subscribe<QueryResult extends object, QueryInputVariables extends object>({ query, variables, observer, }: {\r\n        query: string;\r\n        variables: QueryInputVariables;\r\n        observer: Observer<GraphQLResult<QueryResult>>;\r\n    }): {\r\n        close: () => void;\r\n        data: () => GraphQLResult<QueryResult>;\r\n    };\r\n    mutate<MutationInputVariables extends object, MutationOutput>({ query, variables, }: {\r\n        query: string;\r\n        variables: MutationInputVariables;\r\n    }): Promise<MutationOutput>;\r\n    notify(subscription: Subscription<object, object>): void;\r\n    retry(id: string): void;\r\n    open(): void;\r\n    close(): void;\r\n    send(message: OutEnvelope): void;\r\n    handleOpen(): void;\r\n    handleClose(): void;\r\n    handleMessage(envelope: InEnvelope): void;\r\n}\r\nexport { Connection };\r\n"}}
