{"code":"import React from \"react\";\r\nimport { isEqual } from \"lodash\";\r\nimport { Consumer } from \"./context\";\r\nexport function Query(props) {\r\n    return (React.createElement(Consumer, null, connection => React.createElement(GraphQLRenderer, Object.assign({ connection: connection }, props))));\r\n}\r\nclass GraphQLRenderer extends React.PureComponent {\r\n    componentWillMount() {\r\n        const { query, variables } = this.props;\r\n        this.subscribe({ query, variables });\r\n    }\r\n    componentWillReceiveProps(nextProps) {\r\n        const { query, variables } = nextProps;\r\n        if (isEqual(query, this.state.query) &&\r\n            isEqual(variables, this.state.variables)) {\r\n            return;\r\n        }\r\n        this.subscribe({ query, variables });\r\n    }\r\n    componentWillUnmount() {\r\n        this.unsubscribe();\r\n    }\r\n    render() {\r\n        const { query, variables } = this.props;\r\n        // If the current state is valid (subscribed/cached), we can render the data.\r\n        const hasValidValue = this.state.state === \"subscribed\" || this.state.state === \"cached\";\r\n        // If we are loading a new query and the previous query is the same (but with different query variables),\r\n        // show the last value if it exists.\r\n        const hasPreviousValue = this.state.state === \"loading\" && isEqual(query, this.state.query);\r\n        // If we are rendering an error, show the last value if it exists are the query\r\n        // and its variables are exactly the same. (i.e. a refresh of the data failed).\r\n        const hasValueFromBeforeError = this.state.state === \"error\" &&\r\n            isEqual(query, this.state.query) &&\r\n            isEqual(variables, this.state.variables);\r\n        const shouldRenderValue = hasValidValue || hasPreviousValue || hasValueFromBeforeError;\r\n        const data = {\r\n            value: shouldRenderValue ? this.state.value : undefined,\r\n            state: this.state.state,\r\n            error: this.state.error,\r\n        };\r\n        return this.props.children(data);\r\n    }\r\n    onData(data, query, variables) {\r\n        let partialState = null;\r\n        if (data.state === \"subscribed\" || data.state === \"cached\") {\r\n            partialState = {\r\n                value: data.value,\r\n                query,\r\n                variables,\r\n            };\r\n        }\r\n        this.setState(Object.assign({ state: data.state, error: data.error }, partialState));\r\n    }\r\n    subscribe({ query, variables, }) {\r\n        this.unsubscribe();\r\n        this.subscription = this.props.connection.subscribe({\r\n            query,\r\n            variables,\r\n            observer: data => this.onData(data, query, variables),\r\n        });\r\n        this.onData(this.subscription.data(), query, variables);\r\n    }\r\n    unsubscribe() {\r\n        if (this.subscription) {\r\n            this.subscription.close();\r\n            this.subscription = undefined;\r\n        }\r\n    }\r\n}\r\n","dts":{"name":"/Users/shahryartariq/thunderenum/src/github.com/samsarahq/thunder/example/client/query.d.ts","text":"import React from \"react\";\r\nimport { GraphQLResult } from \"./connection\";\r\ninterface QueryProps<QueryResult extends object, QueryInputVariables extends object> {\r\n    children: (data: GraphQLResult<QueryResult>) => React.ReactNode;\r\n    query: string;\r\n    variables: QueryInputVariables;\r\n}\r\nexport declare function Query<Result extends object, Input extends object>(props: QueryProps<Result, Input>): JSX.Element;\r\nexport {};\r\n"}}
